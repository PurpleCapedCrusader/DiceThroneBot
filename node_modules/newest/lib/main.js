"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _chalk = _interopRequireDefault(require("chalk"));

var _commander = _interopRequireDefault(require("commander"));

var _micromatch = _interopRequireDefault(require("micromatch"));

var _applyUpdates = require("./applyUpdates");

var _readPackage = require("./readPackage");

var _resolveMinVersions = require("./resolveMinVersions");

var _resolveUpdateVersions = require("./resolveUpdateVersions");

var _selectUpdates = require("./selectUpdates");

var _confirmInteractive = require("./confirmInteractive");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = async () => {
  // Remove npm_* variables from the environment because they block correct
  // usage of the .npmrc file.
  Object.keys(process.env).filter(key => key.startsWith("npm_")).forEach(key => delete process.env[key]);

  const appPkg = require("../package.json");

  _commander.default.storeOptionsAsProperties(false).usage("newest [options] [globs...]").version(appPkg.version, "-v, --version").option("-a, --all", "Update everything without asking.").option("-i, --interactive", "Skip the interactivity confirmation.").on("--help", () => {
    console.log();
    console.log("If any glob arguments are given, only matching packages will be updated.");
    console.log();
  }).parse(process.argv);

  const options = _commander.default.opts();

  const globs = _commander.default.args;

  if (!options.interactive && !process.stdout.isTTY) {
    return;
  }

  console.log(_chalk.default.gray(`Newest ${appPkg.version}`));
  const {
    indent,
    pkg
  } = await (0, _readPackage.readPackage)();
  const minVersions = (0, _resolveMinVersions.resolveMinVersions)(pkg);

  if (globs.length > 0) {
    const matches = (0, _micromatch.default)([...minVersions.keys()], globs, {});
    [...minVersions.keys()].forEach(key => {
      if (!matches.includes(key)) {
        minVersions.delete(key);
      }
    });
  }

  const updateVersions = await (0, _resolveUpdateVersions.resolveUpdateVersions)(minVersions);

  if (updateVersions.size === 0) {
    console.log(_chalk.default.gray("All packages are up to date."));
    process.exit(0);
  }

  if (!options.all && !options.interactive && !(await (0, _confirmInteractive.confirmInteractive)())) {
    console.log(_chalk.default.gray(`No changes have been made.`));
    process.exit(0);
  }

  const selectedUpdateVersions = options.all ? updateVersions : await (0, _selectUpdates.selectUpdates)(minVersions, updateVersions);

  if (selectedUpdateVersions.size === 0) {
    console.log(_chalk.default.gray(`No changes have been made.`));
    process.exit(0);
  }

  await (0, _applyUpdates.applyUpdates)(indent, pkg, selectedUpdateVersions);
  console.log(_chalk.default.yellow(`Remember to run "npm i" or "yarn" to apply the updated package versions.`));
};

exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9tYWluLnRzIl0sIm5hbWVzIjpbIk9iamVjdCIsImtleXMiLCJwcm9jZXNzIiwiZW52IiwiZmlsdGVyIiwia2V5Iiwic3RhcnRzV2l0aCIsImZvckVhY2giLCJhcHBQa2ciLCJyZXF1aXJlIiwiY29tbWFuZGVyIiwic3RvcmVPcHRpb25zQXNQcm9wZXJ0aWVzIiwidXNhZ2UiLCJ2ZXJzaW9uIiwib3B0aW9uIiwib24iLCJjb25zb2xlIiwibG9nIiwicGFyc2UiLCJhcmd2Iiwib3B0aW9ucyIsIm9wdHMiLCJnbG9icyIsImFyZ3MiLCJpbnRlcmFjdGl2ZSIsInN0ZG91dCIsImlzVFRZIiwiY2hhbGsiLCJncmF5IiwiaW5kZW50IiwicGtnIiwibWluVmVyc2lvbnMiLCJsZW5ndGgiLCJtYXRjaGVzIiwiaW5jbHVkZXMiLCJkZWxldGUiLCJ1cGRhdGVWZXJzaW9ucyIsInNpemUiLCJleGl0IiwiYWxsIiwic2VsZWN0ZWRVcGRhdGVWZXJzaW9ucyIsInllbGxvdyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7O2VBRWUsWUFBWTtBQUN6QjtBQUNBO0FBQ0FBLEVBQUFBLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZQyxPQUFPLENBQUNDLEdBQXBCLEVBQ0dDLE1BREgsQ0FDV0MsR0FBRCxJQUFTQSxHQUFHLENBQUNDLFVBQUosQ0FBZSxNQUFmLENBRG5CLEVBRUdDLE9BRkgsQ0FFWUYsR0FBRCxJQUFTLE9BQU9ILE9BQU8sQ0FBQ0MsR0FBUixDQUFZRSxHQUFaLENBRjNCOztBQUlBLFFBQU1HLE1BQU0sR0FBR0MsT0FBTyxDQUFDLGlCQUFELENBQXRCOztBQUVBQyxxQkFDR0Msd0JBREgsQ0FDNEIsS0FENUIsRUFFR0MsS0FGSCxDQUVTLDZCQUZULEVBR0dDLE9BSEgsQ0FHV0wsTUFBTSxDQUFDSyxPQUhsQixFQUcyQixlQUgzQixFQUlHQyxNQUpILENBSVUsV0FKVixFQUl1QixtQ0FKdkIsRUFLR0EsTUFMSCxDQUtVLG1CQUxWLEVBSytCLHNDQUwvQixFQU1HQyxFQU5ILENBTU0sUUFOTixFQU1nQixNQUFNO0FBQ2xCQyxJQUFBQSxPQUFPLENBQUNDLEdBQVI7QUFDQUQsSUFBQUEsT0FBTyxDQUFDQyxHQUFSLENBQ0UsMEVBREY7QUFHQUQsSUFBQUEsT0FBTyxDQUFDQyxHQUFSO0FBQ0QsR0FaSCxFQWFHQyxLQWJILENBYVNoQixPQUFPLENBQUNpQixJQWJqQjs7QUFlQSxRQUFNQyxPQUFPLEdBQUdWLG1CQUFVVyxJQUFWLEVBQWhCOztBQUNBLFFBQU1DLEtBQUssR0FBR1osbUJBQVVhLElBQXhCOztBQUVBLE1BQUksQ0FBQ0gsT0FBTyxDQUFDSSxXQUFULElBQXdCLENBQUN0QixPQUFPLENBQUN1QixNQUFSLENBQWVDLEtBQTVDLEVBQW1EO0FBQ2pEO0FBQ0Q7O0FBRURWLEVBQUFBLE9BQU8sQ0FBQ0MsR0FBUixDQUFZVSxlQUFNQyxJQUFOLENBQVksVUFBU3BCLE1BQU0sQ0FBQ0ssT0FBUSxFQUFwQyxDQUFaO0FBRUEsUUFBTTtBQUFFZ0IsSUFBQUEsTUFBRjtBQUFVQyxJQUFBQTtBQUFWLE1BQWtCLE1BQU0sK0JBQTlCO0FBQ0EsUUFBTUMsV0FBVyxHQUFHLDRDQUFtQkQsR0FBbkIsQ0FBcEI7O0FBRUEsTUFBSVIsS0FBSyxDQUFDVSxNQUFOLEdBQWUsQ0FBbkIsRUFBc0I7QUFDcEIsVUFBTUMsT0FBTyxHQUFHLHlCQUFXLENBQUMsR0FBR0YsV0FBVyxDQUFDOUIsSUFBWixFQUFKLENBQVgsRUFBb0NxQixLQUFwQyxFQUEyQyxFQUEzQyxDQUFoQjtBQUVBLEtBQUMsR0FBR1MsV0FBVyxDQUFDOUIsSUFBWixFQUFKLEVBQXdCTSxPQUF4QixDQUFpQ0YsR0FBRCxJQUFTO0FBQ3ZDLFVBQUksQ0FBQzRCLE9BQU8sQ0FBQ0MsUUFBUixDQUFpQjdCLEdBQWpCLENBQUwsRUFBNEI7QUFDMUIwQixRQUFBQSxXQUFXLENBQUNJLE1BQVosQ0FBbUI5QixHQUFuQjtBQUNEO0FBQ0YsS0FKRDtBQUtEOztBQUVELFFBQU0rQixjQUFjLEdBQUcsTUFBTSxrREFBc0JMLFdBQXRCLENBQTdCOztBQUVBLE1BQUlLLGNBQWMsQ0FBQ0MsSUFBZixLQUF3QixDQUE1QixFQUErQjtBQUM3QnJCLElBQUFBLE9BQU8sQ0FBQ0MsR0FBUixDQUFZVSxlQUFNQyxJQUFOLENBQVcsOEJBQVgsQ0FBWjtBQUNBMUIsSUFBQUEsT0FBTyxDQUFDb0MsSUFBUixDQUFhLENBQWI7QUFDRDs7QUFFRCxNQUFJLENBQUNsQixPQUFPLENBQUNtQixHQUFULElBQWdCLENBQUNuQixPQUFPLENBQUNJLFdBQXpCLElBQXdDLEVBQUUsTUFBTSw2Q0FBUixDQUE1QyxFQUEyRTtBQUN6RVIsSUFBQUEsT0FBTyxDQUFDQyxHQUFSLENBQVlVLGVBQU1DLElBQU4sQ0FBWSw0QkFBWixDQUFaO0FBQ0ExQixJQUFBQSxPQUFPLENBQUNvQyxJQUFSLENBQWEsQ0FBYjtBQUNEOztBQUVELFFBQU1FLHNCQUFzQixHQUFHcEIsT0FBTyxDQUFDbUIsR0FBUixHQUMzQkgsY0FEMkIsR0FFM0IsTUFBTSxrQ0FBY0wsV0FBZCxFQUEyQkssY0FBM0IsQ0FGVjs7QUFJQSxNQUFJSSxzQkFBc0IsQ0FBQ0gsSUFBdkIsS0FBZ0MsQ0FBcEMsRUFBdUM7QUFDckNyQixJQUFBQSxPQUFPLENBQUNDLEdBQVIsQ0FBWVUsZUFBTUMsSUFBTixDQUFZLDRCQUFaLENBQVo7QUFDQTFCLElBQUFBLE9BQU8sQ0FBQ29DLElBQVIsQ0FBYSxDQUFiO0FBQ0Q7O0FBRUQsUUFBTSxnQ0FBYVQsTUFBYixFQUFxQkMsR0FBckIsRUFBMEJVLHNCQUExQixDQUFOO0FBRUF4QixFQUFBQSxPQUFPLENBQUNDLEdBQVIsQ0FDRVUsZUFBTWMsTUFBTixDQUNHLDBFQURILENBREY7QUFLRCxDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNoYWxrIGZyb20gXCJjaGFsa1wiO1xuaW1wb3J0IGNvbW1hbmRlciBmcm9tIFwiY29tbWFuZGVyXCI7XG5pbXBvcnQgbWljcm9tYXRjaCBmcm9tIFwibWljcm9tYXRjaFwiO1xuaW1wb3J0IHsgYXBwbHlVcGRhdGVzIH0gZnJvbSBcIi4vYXBwbHlVcGRhdGVzXCI7XG5pbXBvcnQgeyByZWFkUGFja2FnZSB9IGZyb20gXCIuL3JlYWRQYWNrYWdlXCI7XG5pbXBvcnQgeyByZXNvbHZlTWluVmVyc2lvbnMgfSBmcm9tIFwiLi9yZXNvbHZlTWluVmVyc2lvbnNcIjtcbmltcG9ydCB7IHJlc29sdmVVcGRhdGVWZXJzaW9ucyB9IGZyb20gXCIuL3Jlc29sdmVVcGRhdGVWZXJzaW9uc1wiO1xuaW1wb3J0IHsgc2VsZWN0VXBkYXRlcyB9IGZyb20gXCIuL3NlbGVjdFVwZGF0ZXNcIjtcbmltcG9ydCB7IGNvbmZpcm1JbnRlcmFjdGl2ZSB9IGZyb20gXCIuL2NvbmZpcm1JbnRlcmFjdGl2ZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyAoKSA9PiB7XG4gIC8vIFJlbW92ZSBucG1fKiB2YXJpYWJsZXMgZnJvbSB0aGUgZW52aXJvbm1lbnQgYmVjYXVzZSB0aGV5IGJsb2NrIGNvcnJlY3RcbiAgLy8gdXNhZ2Ugb2YgdGhlIC5ucG1yYyBmaWxlLlxuICBPYmplY3Qua2V5cyhwcm9jZXNzLmVudilcbiAgICAuZmlsdGVyKChrZXkpID0+IGtleS5zdGFydHNXaXRoKFwibnBtX1wiKSlcbiAgICAuZm9yRWFjaCgoa2V5KSA9PiBkZWxldGUgcHJvY2Vzcy5lbnZba2V5XSk7XG5cbiAgY29uc3QgYXBwUGtnID0gcmVxdWlyZShcIi4uL3BhY2thZ2UuanNvblwiKTtcblxuICBjb21tYW5kZXJcbiAgICAuc3RvcmVPcHRpb25zQXNQcm9wZXJ0aWVzKGZhbHNlKVxuICAgIC51c2FnZShcIm5ld2VzdCBbb3B0aW9uc10gW2dsb2JzLi4uXVwiKVxuICAgIC52ZXJzaW9uKGFwcFBrZy52ZXJzaW9uLCBcIi12LCAtLXZlcnNpb25cIilcbiAgICAub3B0aW9uKFwiLWEsIC0tYWxsXCIsIFwiVXBkYXRlIGV2ZXJ5dGhpbmcgd2l0aG91dCBhc2tpbmcuXCIpXG4gICAgLm9wdGlvbihcIi1pLCAtLWludGVyYWN0aXZlXCIsIFwiU2tpcCB0aGUgaW50ZXJhY3Rpdml0eSBjb25maXJtYXRpb24uXCIpXG4gICAgLm9uKFwiLS1oZWxwXCIsICgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCk7XG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgXCJJZiBhbnkgZ2xvYiBhcmd1bWVudHMgYXJlIGdpdmVuLCBvbmx5IG1hdGNoaW5nIHBhY2thZ2VzIHdpbGwgYmUgdXBkYXRlZC5cIlxuICAgICAgKTtcbiAgICAgIGNvbnNvbGUubG9nKCk7XG4gICAgfSlcbiAgICAucGFyc2UocHJvY2Vzcy5hcmd2KTtcblxuICBjb25zdCBvcHRpb25zID0gY29tbWFuZGVyLm9wdHMoKTtcbiAgY29uc3QgZ2xvYnMgPSBjb21tYW5kZXIuYXJncztcblxuICBpZiAoIW9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgIXByb2Nlc3Muc3Rkb3V0LmlzVFRZKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc29sZS5sb2coY2hhbGsuZ3JheShgTmV3ZXN0ICR7YXBwUGtnLnZlcnNpb259YCkpO1xuXG4gIGNvbnN0IHsgaW5kZW50LCBwa2cgfSA9IGF3YWl0IHJlYWRQYWNrYWdlKCk7XG4gIGNvbnN0IG1pblZlcnNpb25zID0gcmVzb2x2ZU1pblZlcnNpb25zKHBrZyk7XG5cbiAgaWYgKGdsb2JzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBtYXRjaGVzID0gbWljcm9tYXRjaChbLi4ubWluVmVyc2lvbnMua2V5cygpXSwgZ2xvYnMsIHt9KTtcblxuICAgIFsuLi5taW5WZXJzaW9ucy5rZXlzKCldLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaWYgKCFtYXRjaGVzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgbWluVmVyc2lvbnMuZGVsZXRlKGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjb25zdCB1cGRhdGVWZXJzaW9ucyA9IGF3YWl0IHJlc29sdmVVcGRhdGVWZXJzaW9ucyhtaW5WZXJzaW9ucyk7XG5cbiAgaWYgKHVwZGF0ZVZlcnNpb25zLnNpemUgPT09IDApIHtcbiAgICBjb25zb2xlLmxvZyhjaGFsay5ncmF5KFwiQWxsIHBhY2thZ2VzIGFyZSB1cCB0byBkYXRlLlwiKSk7XG4gICAgcHJvY2Vzcy5leGl0KDApO1xuICB9XG5cbiAgaWYgKCFvcHRpb25zLmFsbCAmJiAhb3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiAhKGF3YWl0IGNvbmZpcm1JbnRlcmFjdGl2ZSgpKSkge1xuICAgIGNvbnNvbGUubG9nKGNoYWxrLmdyYXkoYE5vIGNoYW5nZXMgaGF2ZSBiZWVuIG1hZGUuYCkpO1xuICAgIHByb2Nlc3MuZXhpdCgwKTtcbiAgfVxuXG4gIGNvbnN0IHNlbGVjdGVkVXBkYXRlVmVyc2lvbnMgPSBvcHRpb25zLmFsbFxuICAgID8gdXBkYXRlVmVyc2lvbnNcbiAgICA6IGF3YWl0IHNlbGVjdFVwZGF0ZXMobWluVmVyc2lvbnMsIHVwZGF0ZVZlcnNpb25zKTtcblxuICBpZiAoc2VsZWN0ZWRVcGRhdGVWZXJzaW9ucy5zaXplID09PSAwKSB7XG4gICAgY29uc29sZS5sb2coY2hhbGsuZ3JheShgTm8gY2hhbmdlcyBoYXZlIGJlZW4gbWFkZS5gKSk7XG4gICAgcHJvY2Vzcy5leGl0KDApO1xuICB9XG5cbiAgYXdhaXQgYXBwbHlVcGRhdGVzKGluZGVudCwgcGtnLCBzZWxlY3RlZFVwZGF0ZVZlcnNpb25zKTtcblxuICBjb25zb2xlLmxvZyhcbiAgICBjaGFsay55ZWxsb3coXG4gICAgICBgUmVtZW1iZXIgdG8gcnVuIFwibnBtIGlcIiBvciBcInlhcm5cIiB0byBhcHBseSB0aGUgdXBkYXRlZCBwYWNrYWdlIHZlcnNpb25zLmBcbiAgICApXG4gICk7XG59O1xuIl19