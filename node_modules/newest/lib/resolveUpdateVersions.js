"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolveUpdateVersions = resolveUpdateVersions;

var _semver = _interopRequireWildcard(require("semver"));

var _getLatestVersion = require("./getLatestVersion");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

async function resolveUpdateVersions(versions) {
  const maxVersions = new Map();

  for (const name of versions.keys()) {
    try {
      const version = versions.get(name);
      const maxVersion = await (0, _getLatestVersion.getLatestVersion)(name);

      if (maxVersion && _semver.default.gt(maxVersion, version)) {
        maxVersions.set(name, new _semver.SemVer(maxVersion));
      }
    } catch (_err) {// Silently ignore missing packages/versions or version errors.
    }
  }

  return maxVersions;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9yZXNvbHZlVXBkYXRlVmVyc2lvbnMudHMiXSwibmFtZXMiOlsicmVzb2x2ZVVwZGF0ZVZlcnNpb25zIiwidmVyc2lvbnMiLCJtYXhWZXJzaW9ucyIsIk1hcCIsIm5hbWUiLCJrZXlzIiwidmVyc2lvbiIsImdldCIsIm1heFZlcnNpb24iLCJzZW12ZXIiLCJndCIsInNldCIsIlNlbVZlciIsIl9lcnIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFDQTs7Ozs7O0FBRU8sZUFBZUEscUJBQWYsQ0FDTEMsUUFESyxFQUV5QjtBQUM5QixRQUFNQyxXQUFXLEdBQUcsSUFBSUMsR0FBSixFQUFwQjs7QUFFQSxPQUFLLE1BQU1DLElBQVgsSUFBbUJILFFBQVEsQ0FBQ0ksSUFBVCxFQUFuQixFQUFvQztBQUNsQyxRQUFJO0FBQ0YsWUFBTUMsT0FBTyxHQUFHTCxRQUFRLENBQUNNLEdBQVQsQ0FBYUgsSUFBYixDQUFoQjtBQUNBLFlBQU1JLFVBQVUsR0FBRyxNQUFNLHdDQUFpQkosSUFBakIsQ0FBekI7O0FBRUEsVUFBSUksVUFBVSxJQUFJQyxnQkFBT0MsRUFBUCxDQUFVRixVQUFWLEVBQXNCRixPQUF0QixDQUFsQixFQUFrRDtBQUNoREosUUFBQUEsV0FBVyxDQUFDUyxHQUFaLENBQWdCUCxJQUFoQixFQUFzQixJQUFJUSxjQUFKLENBQVdKLFVBQVgsQ0FBdEI7QUFDRDtBQUNGLEtBUEQsQ0FPRSxPQUFPSyxJQUFQLEVBQWEsQ0FDYjtBQUNEO0FBQ0Y7O0FBRUQsU0FBT1gsV0FBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHNlbXZlciwgeyBTZW1WZXIgfSBmcm9tICdzZW12ZXInO1xuaW1wb3J0IHsgZ2V0TGF0ZXN0VmVyc2lvbiB9IGZyb20gJy4vZ2V0TGF0ZXN0VmVyc2lvbic7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXNvbHZlVXBkYXRlVmVyc2lvbnMoXG4gIHZlcnNpb25zOiBNYXA8c3RyaW5nLCBTZW1WZXI+XG4pOiBQcm9taXNlPE1hcDxzdHJpbmcsIFNlbVZlcj4+IHtcbiAgY29uc3QgbWF4VmVyc2lvbnMgPSBuZXcgTWFwPHN0cmluZywgU2VtVmVyPigpO1xuXG4gIGZvciAoY29uc3QgbmFtZSBvZiB2ZXJzaW9ucy5rZXlzKCkpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdmVyc2lvbiA9IHZlcnNpb25zLmdldChuYW1lKSE7XG4gICAgICBjb25zdCBtYXhWZXJzaW9uID0gYXdhaXQgZ2V0TGF0ZXN0VmVyc2lvbihuYW1lKTtcblxuICAgICAgaWYgKG1heFZlcnNpb24gJiYgc2VtdmVyLmd0KG1heFZlcnNpb24sIHZlcnNpb24pKSB7XG4gICAgICAgIG1heFZlcnNpb25zLnNldChuYW1lLCBuZXcgU2VtVmVyKG1heFZlcnNpb24pKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChfZXJyKSB7XG4gICAgICAvLyBTaWxlbnRseSBpZ25vcmUgbWlzc2luZyBwYWNrYWdlcy92ZXJzaW9ucyBvciB2ZXJzaW9uIGVycm9ycy5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF4VmVyc2lvbnM7XG59XG4iXX0=